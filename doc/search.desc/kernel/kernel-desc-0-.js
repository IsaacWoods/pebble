searchState.loadedDescShard("kernel", 0, "Do the final part of a context switch: save all the state …\nDo the actual drop into usermode. This assumes that the …\nOften, the platform will need to put stuff on either the …\nRepresents a stack, either in kernel-space or user-space. …\nTry to allocate a slab out of the allocator. Returns <code>None</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis trait should be implemented by all types that …\nEach kernel object is assigned a unique 64-bit ID, which …\nA kernel object ID of <code>0</code> is reserved as a sentinel value …\nReturns a boxed object from a boxed trait object if the …\nReturns an <code>Arc</code>-ed object from an <code>Arc</code>-ed trait object if …\nReturns a mutable reference to the object within the trait …\nReturns an <code>$crate::alloc_reexport::rc::Rc</code>-ed object from …\nReturns a reference to the object within the trait object …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if the trait object wraps an object of type …\nTry to allocate a slot for a Task. Creates a user stack …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAdd a message <em>to</em> this <code>ChannelEnd</code>. Use <code>send</code> if you want to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe actual objects extracted from the handles transferred …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTry to “receive” a message from this <code>ChannelEnd</code>, …\nSend a message through this <code>ChannelEnd</code>, to be received by …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSize of this MemoryObject in bytes.\nThe <code>AddressSpace</code> that this task has been created in cannot …\nThe byte stream describing the capabilities of an image is …\nThe task name is not valid UTF-8.\nThe loader can only load tasks that have a name that can …\nThe kernel stack allocator has run out of slots - this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an <code>Event</code> that is signalled when an interrupt …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe global <code>Scheduler</code> coordinates the main ‘run loop’ …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalled when a userspace task yields or is pre-empted. This …\nStart scheduling! This should be called after a platform …\nThis is the architecture-independent syscall handler. It …\nPoplar supports running asynchronous tasks (which we call …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA SPSC (Single Producer, Single Consumer) queue built on …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")