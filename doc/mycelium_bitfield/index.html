<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="mycelium-bitfield"><title>mycelium_bitfield - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="mycelium_bitfield" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0-nightly (ad211ced8 2025-01-07)" data-channel="nightly" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../static.files/storage-59e33391.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../mycelium_bitfield/index.html">mycelium_<wbr>bitfield</a><span class="version">0.1.5</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#mycelium-bitfield" title="mycelium-bitfield">mycelium-bitfield</a><ul><li><a href="#what-is-it" title="what is it?">what is it?</a></li><li><a href="#comparison-with-other-crates" title="comparison with other crates">comparison with other crates</a></li><li><a href="#usage" title="usage">usage</a></li></ul></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#traits" title="Traits">Traits</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>mycelium_bitfield</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/mycelium_bitfield/lib.rs.html#1-35">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="mycelium-bitfield"><a class="doc-anchor" href="#mycelium-bitfield">¬ß</a>mycelium-bitfield</h2>
<p>üçÑ bitfield utilities, courtesy of <a href="https://mycelium.elizas.website">Mycelium</a>.</p>
<p><a href="https://crates.io/crates/mycelium-bitfield"><img src="https://img.shields.io/crates/v/mycelium-bitfield.svg" alt="crates.io" /></a>
<a href="https://docs.rs/mycelium-bitfield"><img src="https://docs.rs/mycelium-bitfield/badge.svg" alt="Documentation" /></a>
<a href="https://mycelium.elizas.website/mycelium_bitfield"><img src="https://img.shields.io/netlify/3ec00bb5-251a-4f83-ac7f-3799d95db0e6?label=docs%20%28main%20branch%29" alt="Documentation (HEAD)" /></a>
<a href="../LICENSE"><img src="https://img.shields.io/badge/license-MIT-blue.svg" alt="MIT licensed" /></a>
<a href="https://github.com/hawkw/mycelium/actions/workflows/ci.yml"><img src="https://github.com/hawkw/mycelium/actions/workflows/ci.yml/badge.svg?branch=main" alt="Test Status" /></a>
<a href="https://github.com/sponsors/hawkw"><img src="https://img.shields.io/badge/sponsor-%F0%9F%A4%8D-ff69b4" alt="Sponsor @hawkw on GitHub Sponsors" /></a></p>
<h3 id="what-is-it"><a class="doc-anchor" href="#what-is-it">¬ß</a>what is it?</h3>
<p>This library provides utilities for defining structured bitfields in Rust. It
consists of <a href="https://docs.rs/mycelium-bitfield/latest/mycelium_bitfield/pack/index.html">a set of types</a> for defining ranges that can be packed and
unpacked from an integer value, and a <a href="https://docs.rs/mycelium-bitfield/latest/mycelium_bitfield/macro.bitfield.html"><code>bitfield!</code> macro</a> for
generating bitfield types automatically using the packing types. These
components are modular: it‚Äôs possible to use the packing spec types to
hand-write all of the code that the <code>bitfield!</code> macro would generate.</p>
<p>This crate was originally implemented for usage in the <a href="https://mycelium.elizas.website">Mycelium operating
system</a>, although it is usable in other projects and does not depend
on any Mycelium-specific libraries.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>This is a hobby project. I‚Äôm working on it in my spare time, for my own
personal use. I‚Äôm very happy to share it with the broader Rust community, and
<a href="https://github.com/hawkw/mycelium/compare">contributions</a> and <a href="https://github.com/hawkw/mycelium/issues/new">bug reports</a> are always welcome. However, please remember
that I‚Äôm working on this library <em>for fun</em>, and if it stops being fun‚Ä¶well,
you get the idea.</p>
<p>Anyway, feel free to use and enjoy this crate, and to contribute back as much
as you want to!</p>
</blockquote>
<h3 id="comparison-with-other-crates"><a class="doc-anchor" href="#comparison-with-other-crates">¬ß</a>comparison with other crates</h3>
<p>There are several other crates implementing bitfields or bitfield-related
utilities in Rust. These crates offer different, but sometimes overlapping,
functionality relative to <code>mycelium-bitfield</code>. In particular, the most directly
comparable crates that I‚Äôm currently aware of are the <a href="https://crates.io/crates/modular-bitfield"><code>modular-bitfield</code></a> and
<a href="https://crates.io/crates/bitflags"><code>bitflags</code></a> libraries.</p>
<blockquote>
<p><strong>Note</strong>
This crate exists <em>primarily</em> because I thought it would be fun to write my
own bitfield crate, not because the existing libraries were deficient. It
<em>is</em> possible that I have a somewhat perverse conception of ‚Äúfun‚Äù‚Ä¶</p>
<p>The  <a href="https://crates.io/crates/modular-bitfield"><code>modular-bitfield</code></a> crate, in particular, can do most of the same things as
<code>mycelium-bitfield</code>. However, there are some differences between the two
libraries which may be interesting to consider.</p>
</blockquote>
<ul>
<li>
<p><strong><a href="https://crates.io/crates/bitflags"><code>bitflags</code></a></strong>: The <a href="https://crates.io/crates/bitflags"><code>bitflags</code></a> crate provides a declarative macro for
generating a structured type representing a set of bitflags.</p>
<p>The critical difference between <a href="https://crates.io/crates/bitflags"><code>bitflags</code></a>‚Äô <a href="https://docs.rs/bitflags/latest/bitflags/macro.bitflags.html"><code>bitflags!</code></a>
macro and <code>mycelium-bitfield</code>‚Äôs <a href="https://docs.rs/mycelium-bitfield/latest/mycelium_bitfield/macro.bitfield.html"><code>bitfield!</code></a> macro is that the <a href="https://crates.io/crates/bitflags"><code>bitflags</code></a>
crate only implements bit<em>flags</em>, not bit<em>fields</em>. It is not possible to
define multi-bit structured ranges using <a href="https://crates.io/crates/bitflags"><code>bitflags</code></a>; only single-bit flags
can be set and unset.</p>
<p>However, the <a href="https://crates.io/crates/bitflags"><code>bitflags</code></a> crate is widely used, has been around for a long
time, and is relatively simple and lightweight. If all you need is a set of
boolean, single-bit flags, it‚Äôs a very solid choice. But, if you need
<code>mycelium-bitfield</code>‚Äôs additional functionality for working with multi-bit
ranges, note that it can also do most most of what the <code>bitflags</code> crate can
do.</p>
</li>
<li>
<p><strong><a href="https://crates.io/crates/modular-bitfield"><code>modular-bitfield</code></a></strong>: The <a href="https://crates.io/crates/modular-bitfield"><code>modular-bitfield</code></a> crate provides a procedural
macro for generating typed structured bitfields.</p>
<p>The functionality implemented by <a href="https://crates.io/crates/modular-bitfield"><code>modular-bitfield</code></a> is broadly very similar
to <code>mycelium-bitfield</code> ‚Äî the two libraries can do most of the same
things.</p>
<p>The primary difference is that <a href="https://crates.io/crates/modular-bitfield"><code>modular-bitfield</code></a> is implemented
using a procedural macro attribute, while <code>mycelium-bitfield</code>‚Äôs
<a href="https://docs.rs/mycelium-bitfield/latest/mycelium_bitfield/macro.bitfield.html"><code>bitfield!</code> macro</a> is a declarative macro. In my opinion,
this isn‚Äôt a reason to prefer <code>mycelium-bitfield</code> over <a href="https://crates.io/crates/modular-bitfield"><code>modular-bitfield</code></a> in
most use cases. I decided to try to write the whole thing using a declarative
macro because I thought it would be a fun challenge, not because it‚Äôs
<em>better</em> (in fact, it would probably have been much easier to implement
the bitfield type generation using a procedural macro). However, users who
need to reduce or avoid procedural macros for some reason may want to consider
choosing <code>mycelium-bitfield</code> for that reason.</p>
<p>The other primary difference between <code>mycelium-bitfield</code> and
<a href="https://crates.io/crates/modular-bitfield"><code>modular-bitfield</code></a> is that <code>mycelium-bitfield</code> also provides the
<a href="https://docs.rs/mycelium-bitfield/latest/mycelium_bitfield/pack/index.html"><code>pack</code></a> module with packing spec types. These types can be used to
build bitfield types ‚Äúby hand‚Äù, in cases where different behavior from the
macro-generated code is needed. <a href="https://crates.io/crates/modular-bitfield"><code>modular-bitfield</code></a> only provides a
procedural macro, and does not have an equivalent to this lower-level
interface.</p>
<p>On the other hand, <a href="https://crates.io/crates/modular-bitfield"><code>modular-bitfield</code></a> provides
<a href="https://docs.rs/modular-bitfield/latest/modular_bitfield/#example-extra-safety-guard">nicer validation</a> that a typed value used as part of a
bitfield actually fits in that bitfield. <code>mycelium-bitfield</code> cannot currently
do this kind of compile-time checking, and relies on implementations of the
<a href="https://docs.rs/mycelium-bitfield/latest/mycelium_bitfield/trait.FromBits.html"><code>FromBits</code> trait</a> for user-provided types being correct.</p>
</li>
</ul>
<h3 id="usage"><a class="doc-anchor" href="#usage">¬ß</a>usage</h3>
<p>This crate‚Äôs API consists of three primary components, the <a href="#packing-spec-types">packing spec
types</a>, the <a href="#bitfield-macro"><code>bitfield! macro</code></a>, and the
<a href="#frombits-trait"><code>FromBits</code> trait</a>.</p>
<h5 id="packing-spec-types"><a class="doc-anchor" href="#packing-spec-types">¬ß</a>packing spec types</h5>
<p>The <a href="https://docs.rs/mycelium-bitfield/latest/mycelium_bitfield/pack/index.html"><code>pack</code> module</a> defines a set of types that can be used to pack and
unpack ranges from integer values of various sizes, such as <a href="https://docs.rs/mycelium-bitfield/latest/mycelium_bitfield/pack/struct.Pack64.html"><code>Pack64</code></a> for
packing and unpacking a range from a <code>u64</code> value.</p>
<p>These packing spec types have <code>const fn</code> constructors that allow them to be
defined in relationship with each other. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>mycelium_bitfield::Pack64;

<span class="comment">// Defines a packing spec for the least-significant 12 bits of a 64-bit value.
</span><span class="kw">const </span>LOW: Pack64 = Pack64::least_significant(<span class="number">12</span>);
<span class="comment">// Defines a packing spec for the next 8 more-significant bits after `LOW`.
</span><span class="kw">const </span>MID: Pack64 = LOW.next(<span class="number">8</span>);
<span class="comment">// Defines a packing spec for the next 4 more-significant bits after `MID`.
</span><span class="kw">const </span>HIGH: Pack64 = MID.next(<span class="number">4</span>);

<span class="comment">// Wrap an integer value to pack it using method calls.
</span><span class="kw">let </span>coffee = Pack64::pack_in(<span class="number">0</span>)
    <span class="comment">// pack the 12 bits of `0xfee` at the range specified by `LOW`.
    </span>.pack(<span class="number">0xfee</span>, <span class="kw-2">&amp;</span>LOW)
    <span class="comment">// pack the 4 bits `0xc` at the range specified by `HIGH`.
    </span>.pack(<span class="number">0xc</span>, <span class="kw-2">&amp;</span>HIGH)
    <span class="comment">// pack `0xf` in the 8 bits specified by `MID`.
    </span>.pack(<span class="number">0xf</span>, <span class="kw-2">&amp;</span>MID)
    <span class="comment">// unwrap the packing value back into a `u64`.
    </span>.bits();

<span class="macro">assert_eq!</span>(coffee, <span class="number">0xc0ffee</span>); <span class="comment">// i want c0ffee</span></code></pre></div>
<p>A majority of the functions in the <a href="https://docs.rs/mycelium-bitfield/latest/mycelium_bitfield/pack/index.html"><code>pack</code></a> module are <code>const fn</code>s, allowing
the use of packing specs in const contexts.</p>
<p>See the <a href="https://docs.rs/mycelium-bitfield/latest/mycelium_bitfield/pack/index.html">module-level docs for <code>pack</code></a> for details.</p>
<h5 id="bitfield-macro"><a class="doc-anchor" href="#bitfield-macro">¬ß</a><code>bitfield!</code> macro</h5>
<p>The <a href="https://docs.rs/mycelium-bitfield/latest/mycelium_bitfield/macro.bitfield.html"><code>bitfield!</code></a> macro allows defining a structured bitfield type
declaratively. The macro will generate code that uses the <code>pack</code> module‚Äôs
packing spec APIs to represent a bitfield type.</p>
<p>For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">mycelium_bitfield::bitfield!</span> {
    <span class="doccomment">/// Bitfield types can have doc comments.
    </span><span class="attr">#[derive(Eq, PartialEq)] </span><span class="comment">// ...and attributes
    </span><span class="kw">pub struct </span>MyBitfield&lt;u16&gt; {
        <span class="doccomment">/// Generates a packing spec named `HELLO` for the first 6
        /// least-significant bits.
        </span><span class="kw">pub const </span>HELLO = <span class="number">6</span>;

        <span class="comment">// Fields with names starting with `_` can be used to mark bits as
        // reserved.
        </span><span class="kw">const </span>_RESERVED = <span class="number">4</span>;

        <span class="doccomment">/// Generates a packing spec named `WORLD` for the next 3 bits.
        </span><span class="kw">pub const </span>WORLD = <span class="number">3</span>;

        <span class="doccomment">/// A boolean value will generate a packing spec for a single bit.
        </span><span class="kw">pub const </span>FLAG: bool;
    }
}

<span class="comment">// Bitfield types can be cheaply constructed from a raw numeric
// representation:
</span><span class="kw">let </span>bitfield = MyBitfield::from_bits(<span class="number">0b10100_0011_0101</span>);

<span class="comment">// `get` methods can be used to unpack fields from a bitfield type:
</span><span class="macro">assert_eq!</span>(bitfield.get(MyBitfield::HELLO), <span class="number">0b11_0101</span>);
<span class="macro">assert_eq!</span>(bitfield.get(MyBitfield::WORLD), <span class="number">0b0101</span>);

<span class="comment">// `with` methods can be used to pack bits into a bitfield type by
// value:
</span><span class="kw">let </span>bitfield2 = MyBitfield::new()
    .with(MyBitfield::HELLO, <span class="number">0b11_0101</span>)
    .with(MyBitfield::WORLD, <span class="number">0b0101</span>);

<span class="macro">assert_eq!</span>(bitfield, bitfield2);

<span class="comment">// `set` methods can be used to mutate a bitfield type in place:
</span><span class="kw">let </span><span class="kw-2">mut </span>bitfield3 = MyBitfield::new();

bitfield3
    .set(MyBitfield::HELLO, <span class="number">0b011_0101</span>)
    .set(MyBitfield::WORLD, <span class="number">0b0101</span>);

<span class="macro">assert_eq!</span>(bitfield, bitfield3);</code></pre></div>
<p>See the <a href="https://docs.rs/mycelium-bitfield/latest/mycelium_bitfield/macro.bitfield.html"><code>bitfield!</code></a> macro‚Äôs documentation for details on the macro‚Äôs usage
and the code it generates.</p>
<h5 id="frombits-trait"><a class="doc-anchor" href="#frombits-trait">¬ß</a><code>FromBits</code> trait</h5>
<p>The <a href="https://docs.rs/mycelium-bitfield/latest/mycelium_bitfield/trait.FromBits.html"><code>FromBits</code></a> trait can be implemented for user-defined types which can be
used as subfields of a <a href="https://docs.rs/mycelium-bitfield/latest/mycelium_bitfield/macro.bitfield.html"><code>bitfield!</code></a>-generated structured bitfield type. This
trait may be manually implemented for any user-defined type that has a defined
bit representation, or generated automatically for <code>enum</code> types using the
<a href="https://docs.rs/mycelium-bitfield/latest/mycelium_bitfield/macro.enum_from_bits.html"><code>enum_from_bits!</code></a> macro.</p>
<p>For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>mycelium_bitfield::{bitfield, enum_from_bits, FromBits};

<span class="comment">// An enum type can implement the `FromBits` trait if it has a
// `#[repr(uN)]` attribute.
</span><span class="attr">#[repr(u8)]
#[derive(Debug, Eq, PartialEq)]
</span><span class="kw">enum </span>MyEnum {
    Foo = <span class="number">0b00</span>,
    Bar = <span class="number">0b01</span>,
    Baz = <span class="number">0b10</span>,
}

<span class="kw">impl </span>FromBits&lt;u32&gt; <span class="kw">for </span>MyEnum {
    <span class="comment">// Two bits can represent all possible `MyEnum` values.
    </span><span class="kw">const </span>BITS: u32 = <span class="number">2</span>;
    <span class="kw">type </span>Error = <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str;

    <span class="kw">fn </span>try_from_bits(bits: u32) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>, <span class="self">Self</span>::Error&gt; {
        <span class="kw">match </span>bits <span class="kw">as </span>u8 {
            bits <span class="kw">if </span>bits == <span class="self">Self</span>::Foo <span class="kw">as </span>u8 =&gt; <span class="prelude-val">Ok</span>(<span class="self">Self</span>::Foo),
            bits <span class="kw">if </span>bits == <span class="self">Self</span>::Bar <span class="kw">as </span>u8 =&gt; <span class="prelude-val">Ok</span>(<span class="self">Self</span>::Bar),
            bits <span class="kw">if </span>bits == <span class="self">Self</span>::Baz <span class="kw">as </span>u8 =&gt; <span class="prelude-val">Ok</span>(<span class="self">Self</span>::Baz),
            <span class="kw">_ </span>=&gt; <span class="prelude-val">Err</span>(<span class="string">"expected one of 0b00, 0b01, or 0b10"</span>),
        }
    }

    <span class="kw">fn </span>into_bits(<span class="self">self</span>) -&gt; u32 {
        <span class="self">self </span><span class="kw">as </span>u8 <span class="kw">as </span>u32
    }
}

<span class="comment">// Alternatively, the `enum_from_bits!` macro can be used to
// automatically generate a `FromBits` implementation for an
// enum type:
</span><span class="macro">enum_from_bits!</span> {
    <span class="attr">#[derive(Debug, Eq, PartialEq)]
    </span><span class="kw">pub enum </span>MyGeneratedEnum&lt;u8&gt; {
        <span class="doccomment">/// Isn't this cool?
        </span>Wow = <span class="number">0b1001</span>,
        <span class="doccomment">/// It sure is! :D
        </span>Whoa = <span class="number">0b0110</span>,
    }
}

<span class="macro">bitfield!</span> {
    <span class="kw">pub struct </span>TypedBitfield&lt;u32&gt; {
        <span class="doccomment">/// Use the first two bits to represent a typed `MyEnum` value.
        </span><span class="kw">const </span>ENUM_VALUE: MyEnum;

        <span class="doccomment">/// Typed values and untyped raw bit fields can be used in the
        /// same bitfield type.
        </span><span class="kw">pub const </span>SOME_BITS = <span class="number">6</span>;

        <span class="doccomment">/// The `FromBits` trait is also implemented for `bool`, which
        /// can be used to implement bitflags.
        </span><span class="kw">pub const </span>FLAG_1: bool;
        <span class="kw">pub const </span>FLAG_2: bool;

        <span class="doccomment">/// `FromBits` is also implemented by (signed and unsigned) integer
        /// types. This will allow the next 8 bits to be treated as a `u8`.
        </span><span class="kw">pub const </span>A_BYTE: u8;

        <span class="doccomment">/// We can also use the automatically generated enum:
        </span><span class="kw">pub const </span>OTHER_ENUM: MyGeneratedEnum;
    }
}

<span class="comment">// Unpacking a typed value with `get` will return that value, or panic if
// the bit pattern is invalid:
</span><span class="kw">let </span>my_bitfield = TypedBitfield::from_bits(<span class="number">0b0010_0100_0011_0101_1001_1110</span>);

<span class="macro">assert_eq!</span>(my_bitfield.get(TypedBitfield::ENUM_VALUE), MyEnum::Baz);
<span class="macro">assert_eq!</span>(my_bitfield.get(TypedBitfield::FLAG_1), <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(my_bitfield.get(TypedBitfield::FLAG_2), <span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(my_bitfield.get(TypedBitfield::OTHER_ENUM), MyGeneratedEnum::Wow);

<span class="comment">// The `try_get` method will return an error rather than panicking if an
// invalid bit pattern is encountered:

</span><span class="kw">let </span>invalid = TypedBitfield::from_bits(<span class="number">0b0011</span>);

<span class="comment">// There is no `MyEnum` variant for 0b11.
</span><span class="macro">assert!</span>(invalid.try_get(TypedBitfield::ENUM_VALUE).is_err());</code></pre></div>
<p>See the <a href="https://docs.rs/mycelium-bitfield/latest/mycelium_bitfield/trait.FromBits.html"><code>FromBits</code> trait documentation</a> for details on
implementing <a href="https://docs.rs/mycelium-bitfield/latest/mycelium_bitfield/trait.FromBits.html"><code>FromBits</code></a> for user-defined types.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">¬ß</a></h2><ul class="item-table"><li><div class="item-name"><code>pub use self::<a class="mod" href="pack/index.html" title="mod mycelium_bitfield::pack">pack</a>::*;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">¬ß</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="pack/index.html" title="mod mycelium_bitfield::pack">pack</a></div><div class="desc docblock-short">Packing spec types.</div></li></ul><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">¬ß</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.bitfield.html" title="macro mycelium_bitfield::bitfield">bitfield</a></div><div class="desc docblock-short">Generates a typed bitfield struct.</div></li><li><div class="item-name"><a class="macro" href="macro.enum_from_bits.html" title="macro mycelium_bitfield::enum_from_bits">enum_<wbr>from_<wbr>bits</a></div><div class="desc docblock-short">Generates automatic <a href="trait.FromBits.html" title="trait mycelium_bitfield::FromBits"><code>FromBits</code></a> and <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom"><code>core::convert::TryFrom</code></a>
implementations for an <code>enum</code> type of <a href="https://doc.rust-lang.org/reference/type-layout.html#primitive-representations"><code>repr(uN)</code></a>, where <code>uN</code> is one of
<a href="https://doc.rust-lang.org/nightly/core/primitive.u8.html" title="primitive u8"><code>u8</code></a>, <a href="https://doc.rust-lang.org/nightly/core/primitive.u16.html" title="primitive u16"><code>u16</code></a>, <a href="https://doc.rust-lang.org/nightly/core/primitive.u32.html" title="primitive u32"><code>u32</code></a>, <a href="https://doc.rust-lang.org/nightly/core/primitive.u64.html" title="primitive u64"><code>u64</code></a>, or <a href="https://doc.rust-lang.org/nightly/core/primitive.u128.html" title="primitive u128"><code>u128</code></a>.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">¬ß</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.FromBits.html" title="trait mycelium_bitfield::FromBits">From<wbr>Bits</a></div><div class="desc docblock-short">Trait implemented by values which can be converted to and from raw bits.</div></li></ul></section></div></main></body></html>