<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A `Timer` tracks the current time, and notifies `Sleep` and `Timeout` futures when they complete."><title>Timer in maitake::time - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="maitake" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0-nightly (0aeaa5eb2 2024-12-14)" data-channel="nightly" data-search-js="search-92e6798f.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../maitake/index.html">maitake</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Timer</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#creating-futures" title="Creating Futures">Creating Futures</a><ul><li><a href="#setting-a-global-timer" title="Setting a Global Timer">Setting a Global Timer</a></li></ul></li><li><a href="#driving-timers" title="Driving Timers">Driving Timers</a><ul><li><a href="#interrupt-driven-timers" title="Interrupt-Driven Timers">Interrupt-Driven Timers</a></li><li><a href="#periodic-and-one-shot-timer-interrupts" title="Periodic and One-Shot Timer Interrupts">Periodic and One-Shot Timer Interrupts</a></li><li><a href="#timestamp-driven-timers" title="Timestamp-Driven Timers">Timestamp-Driven Timers</a></li></ul></li><li><a href="#timer-granularity" title="Timer Granularity">Timer Granularity</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.advance" title="advance">advance</a></li><li><a href="#method.advance_ticks" title="advance_ticks">advance_ticks</a></li><li><a href="#method.force_advance" title="force_advance">force_advance</a></li><li><a href="#method.force_advance_ticks" title="force_advance_ticks">force_advance_ticks</a></li><li><a href="#method.max_duration" title="max_duration">max_duration</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.pend_duration" title="pend_duration">pend_duration</a></li><li><a href="#method.pend_ticks" title="pend_ticks">pend_ticks</a></li><li><a href="#method.sleep" title="sleep">sleep</a></li><li><a href="#method.sleep_ticks" title="sleep_ticks">sleep_ticks</a></li><li><a href="#method.timeout" title="timeout">timeout</a></li><li><a href="#method.try_sleep" title="try_sleep">try_sleep</a></li><li><a href="#method.try_timeout" title="try_timeout">try_timeout</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Debug-for-Timer" title="Debug">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-Timer" title="!Freeze">!Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Timer" title="!RefUnwindSafe">!RefUnwindSafe</a></li><li><a href="#impl-UnwindSafe-for-Timer" title="!UnwindSafe">!UnwindSafe</a></li><li><a href="#impl-Send-for-Timer" title="Send">Send</a></li><li><a href="#impl-Sync-for-Timer" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-Timer" title="Unpin">Unpin</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Instrument-for-T" title="Instrument">Instrument</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In maitake::<wbr>time</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">maitake</a>::<wbr><a href="index.html">time</a></span><h1>Struct <span class="struct">Timer</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/maitake/time/timer.rs.html#187-233">Source</a> </span></div><pre class="rust item-decl"><code>pub struct Timer { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A <code>Timer</code> tracks the current time, and notifies <a href="struct.Sleep.html" title="struct maitake::time::Sleep"><code>Sleep</code></a> and <a href="struct.Timeout.html" title="struct maitake::time::Timeout"><code>Timeout</code></a>
<a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">future</a>s when they complete.</p>
<p>This timer implementation uses a <a href="http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf">hierarchical timer wheel</a> to track
large numbers of <code>Sleep</code> futures efficiently.</p>
<h2 id="creating-futures"><a class="doc-anchor" href="#creating-futures">§</a>Creating Futures</h2>
<p>A <code>Timer</code> instance is necessary to create <a href="struct.Sleep.html" title="struct maitake::time::Sleep"><code>Sleep</code></a> and <a href="struct.Timeout.html" title="struct maitake::time::Timeout"><code>Timeout</code></a> futures.
Once a <a href="struct.Sleep.html" title="struct maitake::time::Sleep"><code>Sleep</code></a> or <a href="struct.Timeout.html" title="struct maitake::time::Timeout"><code>Timeout</code></a> future is created by a <code>Timer</code>, they are
<em>bound</em> to that <code>Timer</code> instance, and will be woken by the <code>Timer</code> once it
advances past the deadline for that future.</p>
<p>The <a href="struct.Timer.html#method.sleep" title="method maitake::time::Timer::sleep"><code>Timer::sleep</code></a> and <a href="struct.Timer.html#method.timeout" title="method maitake::time::Timer::timeout"><code>Timer::timeout</code></a> methods create <a href="struct.Sleep.html" title="struct maitake::time::Sleep"><code>Sleep</code></a> and
<a href="struct.Timeout.html" title="struct maitake::time::Timeout"><code>Timeout</code></a> futures, respectively. In addition, fallible
<a href="struct.Timer.html#method.try_sleep" title="method maitake::time::Timer::try_sleep"><code>Timer::try_sleep</code></a> and <a href="struct.Timer.html#method.try_timeout" title="method maitake::time::Timer::try_timeout"><code>Timer::try_timeout</code></a> methods are available, which
do not panic on invalid durations. These methods may be used in systems
where panicking must be avoided.</p>
<h4 id="setting-a-global-timer"><a class="doc-anchor" href="#setting-a-global-timer">§</a>Setting a Global Timer</h4>
<p>In addition to creating <a href="struct.Sleep.html" title="struct maitake::time::Sleep"><code>Sleep</code></a> and <a href="struct.Timeout.html" title="struct maitake::time::Timeout"><code>Timeout</code></a> futures using methods on a
<code>Timer</code> instance, a timer may also be set as a [global default timer]. This
allows the use of the free functions <a href="struct.Sleep.html" title="struct maitake::time::Sleep"><code>sleep</code></a>, <a href="struct.Timeout.html" title="struct maitake::time::Timeout"><code>timeout</code></a>,
<a href="fn.try_sleep.html" title="fn maitake::time::try_sleep"><code>try_sleep</code></a>, and <a href="fn.try_timeout.html" title="fn maitake::time::try_timeout"><code>try_timeout</code></a>, which do not require a reference to a
<code>Timer</code> to be passed in. See <a href="index.html#global-timers" title="mod maitake::time">the documentation on global timers</a>
for details.</p>
<h2 id="driving-timers"><a class="doc-anchor" href="#driving-timers">§</a>Driving Timers</h2>
<p>⚠️ <em>A timer wheel at rest will remain at rest unless acted
upon by an outside force!</em></p>
<p>Since <code>maitake</code> is intended for bare-metal platforms without an operating
system, a <code>Timer</code> instance cannot automatically advance time. Instead, it
must be driven by a <em>time source</em>, which calls the <a href="struct.Timer.html#method.advance" title="method maitake::time::Timer::advance"><code>Timer::advance</code></a> method
and/or the <a href="struct.Timer.html#method.pend_duration" title="method maitake::time::Timer::pend_duration"><code>Timer::pend_duration</code></a> and <a href="struct.Timer.html#method.force_advance" title="method maitake::time::Timer::force_advance"><code>Timer::force_advance</code></a> methods.</p>
<p>Depending on the hardware platform, a time source may be a timer interrupt
that fires on a known interval<sup id="fnref1"><a href="#fn1">1</a></sup>, or a timestamp that’s read by reading
from a special register<sup id="fnref2"><a href="#fn2">2</a></sup>, a memory-mapped IO location, or by executing a
special instruction<sup id="fnref3"><a href="#fn3">3</a></sup>. A combination of multiple time sources can also be
used.</p>
<p>In any case, the timer must be advanced periodically by the time source.</p>
<h4 id="interrupt-driven-timers"><a class="doc-anchor" href="#interrupt-driven-timers">§</a>Interrupt-Driven Timers</h4>
<p>When the timer is interrupt-driven, the interrupt handler for the timer
interrupt should call either the <a href="struct.Timer.html#method.pend_duration" title="method maitake::time::Timer::pend_duration"><code>Timer::pend_duration</code></a> or
<a href="struct.Timer.html#method.advance" title="method maitake::time::Timer::advance"><code>Timer::advance</code></a> methods.</p>
<p><a href="struct.Timer.html#method.advance" title="method maitake::time::Timer::advance"><code>Timer::advance</code></a> will attempt to optimistically acquire a spinlock, and
advance the timer if it is acquired, or add to the pending tick counter if
the timer wheel is currently locked. Therefore, it is safe to call in an
interrupt handler, as it and cannot cause a deadlock.</p>
<p>However, if interrupt handlers must be extremely short, the
<a href="struct.Timer.html#method.pend_duration" title="method maitake::time::Timer::pend_duration"><code>Timer::pend_duration</code></a> method can be used, instead. This method will
<em>never</em> acquire a lock, and does not actually turn the timer wheel. Instead,
it always performs only a single atomic add. If the time source is an
interrupt handler which calls <a href="struct.Timer.html#method.pend_duration" title="method maitake::time::Timer::pend_duration"><code>Timer::pend_duration</code></a>, though, the timer
wheel must be turned externally. This can be done by calling the
<a href="struct.Timer.html#method.force_advance_ticks" title="method maitake::time::Timer::force_advance_ticks"><code>Timer::force_advance_ticks</code></a> method periodically outside of the interrupt
handler, with a duration of 0 ticks. In general, this should be done as some
form of runtime bookkeeping action. For example, the timer can be advanced
in a system’s run loop every time the <a href="../scheduler/struct.Scheduler.html#method.tick" title="method maitake::scheduler::Scheduler::tick"><code>Scheduler::tick</code></a> method completes.</p>
<h4 id="periodic-and-one-shot-timer-interrupts"><a class="doc-anchor" href="#periodic-and-one-shot-timer-interrupts">§</a>Periodic and One-Shot Timer Interrupts</h4>
<p>Generally, hardware timer interrupts operate in one of two modes: <em>periodic</em>
timers, which fire on a regular interval, and <em>one-shot</em> timers, where the
timer counts down to a particular time, fires the interrupt, and then stops
until it is reset by software. Depending on the particular hardware
platform, one or both of these timer modes may be available.</p>
<p>Using a periodic timer with the <code>maitake</code> timer wheel is quite simple:
construct the timer wheel with the minimum <a href="#timer-granularity">granularity</a>
set to the period of the timer interrupt, and call
<a href="struct.Timer.html#method.advance_ticks" title="method maitake::time::Timer::advance_ticks"><code>Timer::advance_ticks</code></a><code>(1)</code> or <a href="struct.Timer.html#method.pend_ticks" title="method maitake::time::Timer::pend_ticks"><code>Timer::pend_ticks</code></a><code>(1)</code> in the interrupt
handler, as discused <a href="#interrupt-driven-timers">above</a>.</p>
<p>However, if the hardware platform provides a way to put the processor in a
low-power state while waiting for an interrupt, it may be desirable to
instead use a one-shot timer mode. When a timer wheel is advanced, it
returns a <a href="struct.Turn.html" title="struct maitake::time::Turn"><code>Turn</code></a> structure describing what happened while advancing the
wheel. Among other things, this includes <a href="struct.Turn.html#method.time_to_next_deadline" title="method maitake::time::Turn::time_to_next_deadline">the duration until the next
scheduled timer expires</a>. If the timer is
advanced when the system has no other work to perform, and no new work was
scheduled as a result of advancing the timer wheel to the current time, the
system can then instruct the one-shot timer to fire in
<a href="struct.Turn.html#method.time_to_next_deadline" title="method maitake::time::Turn::time_to_next_deadline"><code>Turn::time_to_next_deadline</code></a>, and put the processor in a low-power state
to wait for that interrupt. This allows the system to idle more efficiently
than if it was woken repeatedly by a periodic timer interrupt.</p>
<h4 id="timestamp-driven-timers"><a class="doc-anchor" href="#timestamp-driven-timers">§</a>Timestamp-Driven Timers</h4>
<p>When the timer is advanced by reading from a time source, the
<a href="struct.Timer.html#method.advance" title="method maitake::time::Timer::advance"><code>Timer::advance</code></a> method should generally be used to drive the timer. Prior
to calling <a href="struct.Timer.html#method.advance" title="method maitake::time::Timer::advance"><code>Timer::advance</code></a>, the time source is read to determine the
duration that has elapsed since the last time <a href="struct.Timer.html#method.advance" title="method maitake::time::Timer::advance"><code>Timer::advance</code></a> was called,
and that duration is provided when calling <code>advance</code>.</p>
<p>This should occur periodically as part of a runtime loop (as discussed in
the previous section), such as every time <a href="../scheduler/struct.Scheduler.html#method.tick" title="method maitake::scheduler::Scheduler::tick">the scheduler is
ticked</a>. Advancing the timer more frequently will result
in <a href="struct.Sleep.html" title="struct maitake::time::Sleep"><code>Sleep</code></a> futures firing with a higher resolution, while less frequent
calls to <a href="struct.Timer.html#method.advance" title="method maitake::time::Timer::advance"><code>Timer::advance</code></a> will result in more noise in when <a href="struct.Sleep.html" title="struct maitake::time::Sleep"><code>Sleep</code></a>
futures actually complete.</p>
<h2 id="timer-granularity"><a class="doc-anchor" href="#timer-granularity">§</a>Timer Granularity</h2>
<p>Within the timer wheel, the duration of a <a href="struct.Sleep.html" title="struct maitake::time::Sleep"><code>Sleep</code></a> future is represented as
a number of abstract “timer ticks”. The actual duration in real life time
that’s represented by a number of ticks depends on the timer’s _granularity.</p>
<p>When constructing a <code>Timer</code> (e.g. by calling <a href="struct.Timer.html#method.new" title="associated function maitake::time::Timer::new"><code>Timer::new</code></a>), the minimum
granularity of the timer is selected by providing the <a href="struct.Duration.html" title="struct maitake::time::Duration"><code>Duration</code></a>
represented by a single timer tick. The selected tick duration influences
both the resolution of the timer (i.e. the minimum difference in duration
between two <code>Sleep</code> futures that can be distinguished by the timer), and
the maximum duration that can be represented by a <code>Sleep</code> future (which is
limited by the size of a 64-bit integer).</p>
<p>A longer tick duration will allow represented longer sleeps, as the maximum
allowable sleep is the timer’s granularity multiplied by <a href="https://doc.rust-lang.org/nightly/core/primitive.u64.html#associatedconstant.MAX" title="associated constant u64::MAX"><code>u64::MAX</code></a>. A
shorter tick duration will allow for more precise sleeps at the expense of
reducing the maximum allowed sleep.</p>
<p>When using an <a href="#interrupt-driven-timers">interrupt-driven time source</a>, the
tick duration should generally be the interval that the timer interrupt
fires at. A finer resolution won’t have any benefit, as the timer only fires
at that frequency, and all sleeps that complete between two timer interrupts
will be woken at the same time anyway.</p>
<p>When using a <a href="#timestamp-driven-timers">timestamp-driven time source</a>,
selecting the resolution of the timestamp counter as the timer’s tick
duration is probably a good choice.</p>
<div class="footnotes"><hr><ol><li id="fn1"><p>Such as the <a href="https://en.wikipedia.org/wiki/Intel_8253#IBM_PC_programming_tips_and_hints">8253 PIT interrupt</a> on most x86 systems.&nbsp;<a href="#fnref1">↩</a></p></li><li id="fn2"><p>Such as the <a href="https://developer.arm.com/documentation/ddi0211/h/system-control-coprocessor/system-control-processor-register-descriptions/c15--cycle-counter-register--ccnt-"><code>CCNT</code> register</a> on ARMv7.&nbsp;<a href="#fnref2">↩</a></p></li><li id="fn3"><p>Such as the <a href="https://www.felixcloutier.com/x86/rdtsc"><code>rdtsc</code> instruction</a> on x86_64.&nbsp;<a href="#fnref3">↩</a></p></li></ol></div></div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Timer" class="impl"><a class="src rightside" href="../../src/maitake/time/timeout.rs.html#149-224">Source</a><a href="#impl-Timer" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Timer.html" title="struct maitake::time::Timer">Timer</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.timeout" class="method"><a class="src rightside" href="../../src/maitake/time/timeout.rs.html#178-183">Source</a><h4 class="code-header">pub fn <a href="#method.timeout" class="fn">timeout</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&gt;(
    &amp;self,
    duration: <a class="struct" href="struct.Duration.html" title="struct maitake::time::Duration">Duration</a>,
    future: F,
) -&gt; <a class="struct" href="struct.Timeout.html" title="struct maitake::time::Timeout">Timeout</a>&lt;'_, F&gt; <a href="#" class="tooltip" data-notable-ty="Timeout&lt;&#39;_, F&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns a new <a href="struct.Timeout.html" title="struct maitake::time::Timeout"><code>Timeout</code></a> future that fails if <code>future</code> does not
complete within the specified <code>duration</code>.</p>
<p>The timeout will be driven by this timer.</p>
<h5 id="output"><a class="doc-anchor" href="#output">§</a>Output</h5>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a><code>(F::Output)</code> if the inner future completed before the specified
timeout.</li>
<li><a href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a><code>(</code><a href="timeout/struct.Elapsed.html" title="struct maitake::time::timeout::Elapsed"><code>Elapsed</code></a><code>)</code> if the timeout elapsed before the inner <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a>
completed.</li>
</ul>
<h5 id="cancellation"><a class="doc-anchor" href="#cancellation">§</a>Cancellation</h5>
<p>Dropping a <code>Timeout</code> future cancels the timeout. The wrapped <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a> can
be extracted from the <code>Timeout</code> future by calling <a href="struct.Timeout.html#method.into_inner" title="method maitake::time::Timeout::into_inner"><code>Timeout::into_inner</code></a>,
allowing the future to be polled without failing if the timeout elapses.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>This method panics if the provided duration exceeds the <a href="struct.Timer.html#method.max_duration" title="method maitake::time::Timer::max_duration">maximum sleep
duration</a> allowed this timer.</p>
<p>For a version of this method that does not panic, use the
<a href="struct.Timer.html#method.try_timeout" title="method maitake::time::Timer::try_timeout"><code>Timer::try_timeout</code></a> method instead.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_timeout" class="method"><a class="src rightside" href="../../src/maitake/time/timeout.rs.html#216-223">Source</a><h4 class="code-header">pub fn <a href="#method.try_timeout" class="fn">try_timeout</a>&lt;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&gt;(
    &amp;self,
    duration: <a class="struct" href="struct.Duration.html" title="struct maitake::time::Duration">Duration</a>,
    future: F,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Timeout.html" title="struct maitake::time::Timeout">Timeout</a>&lt;'_, F&gt;, <a class="enum" href="enum.TimerError.html" title="enum maitake::time::TimerError">TimerError</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a new <a href="struct.Timeout.html" title="struct maitake::time::Timeout"><code>Timeout</code></a> future that fails if <code>future</code> does not
complete within the specified <code>duration</code>.</p>
<p>The timeout will be driven by this timer.</p>
<h5 id="returns"><a class="doc-anchor" href="#returns">§</a>Returns</h5>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a><code>(</code><a href="struct.Timeout.html" title="struct maitake::time::Timeout"><code>Timeout</code></a><code>)</code> if a new <a href="struct.Timeout.html" title="struct maitake::time::Timeout"><code>Timeout</code></a> future was created
successfully.</li>
<li><a href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a><code>(</code><a href="enum.TimerError.html#variant.DurationTooLong" title="variant maitake::time::TimerError::DurationTooLong"><code>TimerError::DurationTooLong</code></a><code>)</code> if the requested timeout
duration exceeds this timer’s <a href="struct.Timer.html#method.max_duration" title="method maitake::time::Timer::max_duration">maximum sleep
duration</a>.</li>
</ul>
<h5 id="output-1"><a class="doc-anchor" href="#output-1">§</a>Output</h5>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a><code>(F::Output)</code> if the inner future completed before the specified
timeout.</li>
<li><a href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a><code>(</code><a href="timeout/struct.Elapsed.html" title="struct maitake::time::timeout::Elapsed"><code>Elapsed</code></a><code>)</code> if the timeout elapsed before the inner <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a>
completed.</li>
</ul>
<h5 id="cancellation-1"><a class="doc-anchor" href="#cancellation-1">§</a>Cancellation</h5>
<p>Dropping a <code>Timeout</code> future cancels the timeout. The wrapped <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a> can
be extracted from the <code>Timeout</code> future by calling <a href="struct.Timeout.html#method.into_inner" title="method maitake::time::Timeout::into_inner"><code>Timeout::into_inner</code></a>,
allowing the future to be polled without failing if the timeout elapses.</p>
<h5 id="panics-1"><a class="doc-anchor" href="#panics-1">§</a>Panics</h5>
<p>This method does not panic. For a version of this methodthat panics
rather than returning a <a href="enum.TimerError.html" title="enum maitake::time::TimerError"><code>TimerError</code></a>, use <a href="struct.Timer.html#method.timeout" title="method maitake::time::Timer::timeout"><code>Timer::timeout</code></a>.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Timer-1" class="impl"><a class="src rightside" href="../../src/maitake/time/timer.rs.html#300-606">Source</a><a href="#impl-Timer-1" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Timer.html" title="struct maitake::time::Timer">Timer</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../src/maitake/time/timer.rs.html#301-312">Source</a><h4 class="code-header">pub const fn <a href="#method.new" class="fn">new</a>(tick_duration: <a class="struct" href="struct.Duration.html" title="struct maitake::time::Duration">Duration</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Returns a new <code>Timer</code> with the specified <code>tick_duration</code> for a single timer
tick.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.max_duration" class="method"><a class="src rightside" href="../../src/maitake/time/timer.rs.html#315-317">Source</a><h4 class="code-header">pub fn <a href="#method.max_duration" class="fn">max_duration</a>(&amp;self) -&gt; <a class="struct" href="struct.Duration.html" title="struct maitake::time::Duration">Duration</a></h4></section></summary><div class="docblock"><p>Returns the maximum duration of <a href="struct.Sleep.html" title="struct maitake::time::Sleep"><code>Sleep</code></a> futures driven by this timer.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.sleep" class="method"><a class="src rightside" href="../../src/maitake/time/timer.rs.html#338-340">Source</a><h4 class="code-header">pub fn <a href="#method.sleep" class="fn">sleep</a>(&amp;self, duration: <a class="struct" href="struct.Duration.html" title="struct maitake::time::Duration">Duration</a>) -&gt; <a class="struct" href="struct.Sleep.html" title="struct maitake::time::Sleep">Sleep</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Sleep&lt;&#39;_&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns a <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a> that will complete in <code>duration</code>.</p>
<h5 id="returns-1"><a class="doc-anchor" href="#returns-1">§</a>Returns</h5>
<p>The returned <a href="struct.Sleep.html" title="struct maitake::time::Sleep"><code>Sleep</code></a> future will be driven by this timer, and will
complete once this timer has advanced by at least <code>duration</code>.</p>
<h5 id="panics-2"><a class="doc-anchor" href="#panics-2">§</a>Panics</h5>
<p>This method panics if the provided duration exceeds the <a href="struct.Timer.html#method.max_duration" title="method maitake::time::Timer::max_duration">maximum sleep
duration</a> allowed by this timer.</p>
<p>For a version of this function that does not panic, see
<a href="struct.Timer.html#method.try_sleep" title="method maitake::time::Timer::try_sleep"><code>Timer::try_sleep</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_sleep" class="method"><a class="src rightside" href="../../src/maitake/time/timer.rs.html#361-364">Source</a><h4 class="code-header">pub fn <a href="#method.try_sleep" class="fn">try_sleep</a>(&amp;self, duration: <a class="struct" href="struct.Duration.html" title="struct maitake::time::Duration">Duration</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Sleep.html" title="struct maitake::time::Sleep">Sleep</a>&lt;'_&gt;, <a class="enum" href="enum.TimerError.html" title="enum maitake::time::TimerError">TimerError</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a> that will complete in <code>duration</code>.</p>
<h5 id="returns-2"><a class="doc-anchor" href="#returns-2">§</a>Returns</h5>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a><code>(</code><a href="struct.Sleep.html" title="struct maitake::time::Sleep"><code>Sleep</code></a><code>)</code> if a new <a href="struct.Sleep.html" title="struct maitake::time::Sleep"><code>Sleep</code></a> future was created
successfully.</li>
<li><a href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a><code>(</code><a href="enum.TimerError.html#variant.DurationTooLong" title="variant maitake::time::TimerError::DurationTooLong"><code>TimerError::DurationTooLong</code></a><code>)</code> if the requested sleep
duration exceeds this timer’s <a href="struct.Timer.html#method.max_duration" title="method maitake::time::Timer::max_duration">maximum sleep
duration</a>.</li>
</ul>
<p>The returned <a href="struct.Sleep.html" title="struct maitake::time::Sleep"><code>Sleep</code></a> future will be driven by this timer, and will
complete once this timer has advanced by at least <code>duration</code>.</p>
<h5 id="panics-3"><a class="doc-anchor" href="#panics-3">§</a>Panics</h5>
<p>This method does not panic. For a version of this method that panics
rather than returning an error, see <a href="struct.Timer.html#method.sleep" title="method maitake::time::Timer::sleep"><code>Timer::sleep</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.sleep_ticks" class="method"><a class="src rightside" href="../../src/maitake/time/timer.rs.html#375-377">Source</a><h4 class="code-header">pub fn <a href="#method.sleep_ticks" class="fn">sleep_ticks</a>(&amp;self, ticks: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u64.html">u64</a>) -&gt; <a class="struct" href="struct.Sleep.html" title="struct maitake::time::Sleep">Sleep</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Sleep&lt;&#39;_&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns a <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a> that will complete in <code>ticks</code> timer ticks.</p>
<h5 id="returns-3"><a class="doc-anchor" href="#returns-3">§</a>Returns</h5>
<p>The returned <a href="struct.Sleep.html" title="struct maitake::time::Sleep"><code>Sleep</code></a> future will be driven by this timer, and will
complete once this timer has advanced by at least <code>ticks</code> timer ticks.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pend_duration" class="method"><a class="src rightside" href="../../src/maitake/time/timer.rs.html#388-394">Source</a><h4 class="code-header">pub fn <a href="#method.pend_duration" class="fn">pend_duration</a>(&amp;self, duration: <a class="struct" href="struct.Duration.html" title="struct maitake::time::Duration">Duration</a>)</h4></section></summary><div class="docblock"><p>Add pending time to the timer <em>without</em> turning the wheel.</p>
<p>This function will <em>never</em> acquire a lock, and will <em>never</em> notify any
waiting <a href="struct.Sleep.html" title="struct maitake::time::Sleep"><code>Sleep</code></a> futures. It can be called in an interrupt handler that
cannot perform significant amounts of work.</p>
<p>However, if this method is used, then <a href="struct.Timer.html#method.force_advance" title="method maitake::time::Timer::force_advance"><code>Timer::force_advance</code></a> must be
called frequently from outside of the interrupt handler.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pend_ticks" class="method"><a class="src rightside" href="../../src/maitake/time/timer.rs.html#406-412">Source</a><h4 class="code-header">pub fn <a href="#method.pend_ticks" class="fn">pend_ticks</a>(&amp;self, ticks: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u64.html">u64</a>)</h4></section></summary><div class="docblock"><p>Add pending ticks to the timer <em>without</em> turning the wheel.</p>
<p>This function will <em>never</em> acquire a lock, and will <em>never</em> notify any
waiting <a href="struct.Sleep.html" title="struct maitake::time::Sleep"><code>Sleep</code></a> futures. It can be called in an interrupt handler that
cannot perform significant amounts of work.</p>
<p>However, if this method is used, then <a href="struct.Timer.html#method.force_advance" title="method maitake::time::Timer::force_advance"><code>Timer::force_advance</code></a> must be
called frequently from outside of the interrupt handler.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.advance" class="method"><a class="src rightside" href="../../src/maitake/time/timer.rs.html#448-451">Source</a><h4 class="code-header">pub fn <a href="#method.advance" class="fn">advance</a>(&amp;self, duration: <a class="struct" href="struct.Duration.html" title="struct maitake::time::Duration">Duration</a>)</h4></section></summary><div class="docblock"><p>Advance the timer by <code>duration</code>, potentially waking any <a href="struct.Sleep.html" title="struct maitake::time::Sleep"><code>Sleep</code></a> futures
that have completed.</p>
<h5 id="returns-4"><a class="doc-anchor" href="#returns-4">§</a>Returns</h5>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#variant.Some" title="variant core::option::Option::Some"><code>Some</code></a><code>(</code><a href="struct.Turn.html" title="struct maitake::time::Turn"><code>Turn</code></a><code>)</code> if the lock was acquired and the wheel was
advanced. A <a href="struct.Turn.html" title="struct maitake::time::Turn"><code>Turn</code></a> structure describes what occurred during this
turn of the wheel, including the <a href="struct.Turn.html#method.elapsed" title="method maitake::time::Turn::elapsed">current time</a> and the
<a href="struct.Turn.html#method.time_to_next_deadline" title="method maitake::time::Turn::time_to_next_deadline">deadline of the next expiring timer</a>, if one exists.</li>
<li><a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> if the wheel was not advanced because the lock was already
held.</li>
</ul>
<h5 id="interrupt-safety"><a class="doc-anchor" href="#interrupt-safety">§</a>Interrupt Safety</h5>
<p>This method will <em>never</em> spin if the timer wheel lock is held; instead,
it will add any new ticks to a counter of “pending” ticks and return
immediately. Therefore, it is safe to call this method in an interrupt
handler, as it will never acquire a lock that may already be locked.</p>
<p>The <a href="struct.Timer.html#method.force_advance" title="method maitake::time::Timer::force_advance"><code>force_advance</code></a> method will spin to lock the timer wheel lock if
it is currently held, <em>ensuring</em> that any pending wakeups are processed.
That method should never be called in an interrupt handler.</p>
<p>If a timer is driven primarily by calling <code>advance</code> in an interrupt
handler, it may be desirable to occasionally call <a href="struct.Timer.html#method.force_advance" title="method maitake::time::Timer::force_advance"><code>force_advance</code></a>
<em>outside</em> of an interrupt handler (i.e., as as part of an occasional
runtime bookkeeping process). This ensures that any pending ticks are
observed by the timer in a relatively timely manner.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.advance_ticks" class="method"><a class="src rightside" href="../../src/maitake/time/timer.rs.html#487-503">Source</a><h4 class="code-header">pub fn <a href="#method.advance_ticks" class="fn">advance_ticks</a>(&amp;self, ticks: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u64.html">u64</a>)</h4></section></summary><div class="docblock"><p>Advance the timer by <code>ticks</code> timer ticks, potentially waking any <a href="struct.Sleep.html" title="struct maitake::time::Sleep"><code>Sleep</code></a>
futures that have completed.</p>
<h5 id="returns-5"><a class="doc-anchor" href="#returns-5">§</a>Returns</h5>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#variant.Some" title="variant core::option::Option::Some"><code>Some</code></a><code>(</code><a href="struct.Turn.html" title="struct maitake::time::Turn"><code>Turn</code></a><code>)</code> if the lock was acquired and the wheel was
advanced. A <a href="struct.Turn.html" title="struct maitake::time::Turn"><code>Turn</code></a> structure describes what occurred during this
turn of the wheel, including the <a href="struct.Turn.html#method.elapsed" title="method maitake::time::Turn::elapsed">current time</a> and the
<a href="struct.Turn.html#method.time_to_next_deadline" title="method maitake::time::Turn::time_to_next_deadline">deadline of the next expiring timer</a>, if one exists.</li>
<li><a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> if the wheel was not advanced because the lock was already
held.</li>
</ul>
<h5 id="interrupt-safety-1"><a class="doc-anchor" href="#interrupt-safety-1">§</a>Interrupt Safety</h5>
<p>This method will <em>never</em> spin if the timer wheel lock is held; instead,
it will add any new ticks to a counter of “pending” ticks and return
immediately. Therefore, it is safe to call this method in an interrupt
handler, as it will never acquire a lock that may already be locked.</p>
<p>The <a href="struct.Timer.html#method.force_advance_ticks" title="method maitake::time::Timer::force_advance_ticks"><code>force_advance_ticks</code></a> method will spin to lock the timer wheel lock if
it is currently held, <em>ensuring</em> that any pending wakeups are processed.
That method should never be called in an interrupt handler.</p>
<p>If a timer is driven primarily by calling <code>advance</code> in an interrupt
handler, it may be desirable to occasionally call <a href="struct.Timer.html#method.force_advance_ticks" title="method maitake::time::Timer::force_advance_ticks"><code>force_advance_ticks</code></a>
<em>outside</em> of an interrupt handler (i.e., as as part of an occasional
runtime bookkeeping process). This ensures that any pending ticks are
observed by the timer in a relatively timely manner.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.force_advance" class="method"><a class="src rightside" href="../../src/maitake/time/timer.rs.html#531-534">Source</a><h4 class="code-header">pub fn <a href="#method.force_advance" class="fn">force_advance</a>(&amp;self, duration: <a class="struct" href="struct.Duration.html" title="struct maitake::time::Duration">Duration</a>) -&gt; <a class="struct" href="struct.Turn.html" title="struct maitake::time::Turn">Turn</a></h4></section></summary><div class="docblock"><p>Advance the timer by <code>duration</code>, ensuring any <code>Sleep</code> futures that have
completed are woken, even if a lock must be acquired.</p>
<h5 id="returns-6"><a class="doc-anchor" href="#returns-6">§</a>Returns</h5>
<p>A <a href="struct.Turn.html" title="struct maitake::time::Turn"><code>Turn</code></a> structure describing what occurred during this turn of the
wheel, including including the <a href="struct.Turn.html#method.elapsed" title="method maitake::time::Turn::elapsed">current time</a> and the <a href="struct.Turn.html#method.time_to_next_deadline" title="method maitake::time::Turn::time_to_next_deadline">deadline
of the next expiring timer</a>, if one exists.</p>
<h5 id="interrupt-safety-2"><a class="doc-anchor" href="#interrupt-safety-2">§</a>Interrupt Safety</h5>
<p>This method will spin to acquire the timer wheel lock if it is currently
held elsewhere. Therefore, this method must <em>NEVER</em> be called in an
interrupt handler!</p>
<p>If a timer is advanced inside an interrupt handler, use the <a href="struct.Timer.html#method.advance" title="method maitake::time::Timer::advance"><code>advance</code></a>
method instead. If a timer is advanced primarily by calls to
<a href="struct.Timer.html#method.advance" title="method maitake::time::Timer::advance"><code>advance</code></a>, it may be desirable to occasionally call <code>force_advance</code>
outside an interrupt handler, to ensure that pending ticks are drained
frequently.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.force_advance_ticks" class="method"><a class="src rightside" href="../../src/maitake/time/timer.rs.html#562-564">Source</a><h4 class="code-header">pub fn <a href="#method.force_advance_ticks" class="fn">force_advance_ticks</a>(&amp;self, ticks: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u64.html">u64</a>) -&gt; <a class="struct" href="struct.Turn.html" title="struct maitake::time::Turn">Turn</a></h4></section></summary><div class="docblock"><p>Advance the timer by <code>ticks</code> timer ticks, ensuring any <code>Sleep</code> futures
that have completed are woken, even if a lock must be acquired.</p>
<h5 id="returns-7"><a class="doc-anchor" href="#returns-7">§</a>Returns</h5>
<p>A <a href="struct.Turn.html" title="struct maitake::time::Turn"><code>Turn</code></a> structure describing what occurred during this turn of the
wheel, including including the <a href="struct.Turn.html#method.elapsed" title="method maitake::time::Turn::elapsed">current time</a> and the <a href="struct.Turn.html#method.time_to_next_deadline" title="method maitake::time::Turn::time_to_next_deadline">deadline
of the next expiring timer</a>, if one exists.</p>
<h5 id="interrupt-safety-3"><a class="doc-anchor" href="#interrupt-safety-3">§</a>Interrupt Safety</h5>
<p>This method will spin to acquire the timer wheel lock if it is currently
held elsewhere. Therefore, this method must <em>NEVER</em> be called in an
interrupt handler!</p>
<p>If a timer is advanced inside an interrupt handler, use the <a href="struct.Timer.html#method.advance_ticks" title="method maitake::time::Timer::advance_ticks"><code>advance_ticks</code></a>
method instead. If a timer is advanced primarily by calls to
<a href="struct.Timer.html#method.advance_ticks" title="method maitake::time::Timer::advance_ticks"><code>advance_ticks</code></a>, it may be desirable to occasionally call <code>force_advance</code>
outside an interrupt handler, to ensure that pending ticks are drained
frequently.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Timer" class="impl"><a class="src rightside" href="../../src/maitake/time/timer.rs.html#608-616">Source</a><a href="#impl-Debug-for-Timer" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Timer.html" title="struct maitake::time::Timer">Timer</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../src/maitake/time/timer.rs.html#609-615">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Timer" class="impl"><a href="#impl-Freeze-for-Timer" class="anchor">§</a><h3 class="code-header">impl !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.Timer.html" title="struct maitake::time::Timer">Timer</a></h3></section><section id="impl-RefUnwindSafe-for-Timer" class="impl"><a href="#impl-RefUnwindSafe-for-Timer" class="anchor">§</a><h3 class="code-header">impl !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Timer.html" title="struct maitake::time::Timer">Timer</a></h3></section><section id="impl-Send-for-Timer" class="impl"><a href="#impl-Send-for-Timer" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Timer.html" title="struct maitake::time::Timer">Timer</a></h3></section><section id="impl-Sync-for-Timer" class="impl"><a href="#impl-Sync-for-Timer" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Timer.html" title="struct maitake::time::Timer">Timer</a></h3></section><section id="impl-Unpin-for-Timer" class="impl"><a href="#impl-Unpin-for-Timer" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Timer.html" title="struct maitake::time::Timer">Timer</a></h3></section><section id="impl-UnwindSafe-for-Timer" class="impl"><a href="#impl-UnwindSafe-for-Timer" class="anchor">§</a><h3 class="code-header">impl !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Timer.html" title="struct maitake::time::Timer">Timer</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#765">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#768">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Instrument-for-T" class="impl"><a class="src rightside" href="../../src/tracing/instrument.rs.html#358">Source</a><a href="#impl-Instrument-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../tracing/instrument/trait.Instrument.html" title="trait tracing::instrument::Instrument">Instrument</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.instrument" class="method trait-impl"><a class="src rightside" href="../../src/tracing/instrument.rs.html#86">Source</a><a href="#method.instrument" class="anchor">§</a><h4 class="code-header">fn <a href="../../tracing/instrument/trait.Instrument.html#method.instrument" class="fn">instrument</a>(self, span: <a class="struct" href="../../tracing/span/struct.Span.html" title="struct tracing::span::Span">Span</a>) -&gt; <a class="struct" href="../../tracing/instrument/struct.Instrumented.html" title="struct tracing::instrument::Instrumented">Instrumented</a>&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the provided <a href="../../tracing/span/struct.Span.html" title="struct tracing::span::Span"><code>Span</code></a>, returning an
<code>Instrumented</code> wrapper. <a href="../../tracing/instrument/trait.Instrument.html#method.instrument">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.in_current_span" class="method trait-impl"><a class="src rightside" href="../../src/tracing/instrument.rs.html#128">Source</a><a href="#method.in_current_span" class="anchor">§</a><h4 class="code-header">fn <a href="../../tracing/instrument/trait.Instrument.html#method.in_current_span" class="fn">in_current_span</a>(self) -&gt; <a class="struct" href="../../tracing/instrument/struct.Instrumented.html" title="struct tracing::instrument::Instrumented">Instrumented</a>&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the <a href="../../tracing/span/struct.Span.html#method.current" title="associated function tracing::span::Span::current">current</a> <a href="../../tracing/span/struct.Span.html" title="struct tracing::span::Span"><code>Span</code></a>, returning an
<code>Instrumented</code> wrapper. <a href="../../tracing/instrument/trait.Instrument.html#method.in_current_span">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#748-750">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#758">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#805-807">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#809">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#812">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#790-792">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#794">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#797">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div><script type="text/json" id="notable-traits-data">{"Sleep<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Sleep.html\" title=\"struct maitake::time::Sleep\">Sleep</a>&lt;'_&gt;</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html\" title=\"trait core::future::future::Future\">Future</a> for <a class=\"struct\" href=\"struct.Sleep.html\" title=\"struct maitake::time::Sleep\">Sleep</a>&lt;'_&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/core/primitive.unit.html\">()</a>;</div>","Timeout<'_, F>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Timeout.html\" title=\"struct maitake::time::Timeout\">Timeout</a>&lt;'_, F&gt;</code></h3><pre><code><div class=\"where\">impl&lt;F: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html\" title=\"trait core::future::future::Future\">Future</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html\" title=\"trait core::future::future::Future\">Future</a> for <a class=\"struct\" href=\"struct.Timeout.html\" title=\"struct maitake::time::Timeout\">Timeout</a>&lt;'_, F&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;F::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html#associatedtype.Output\" title=\"type core::future::future::Future::Output\">Output</a>, <a class=\"struct\" href=\"timeout/struct.Elapsed.html\" title=\"struct maitake::time::timeout::Elapsed\">Elapsed</a>&gt;;</div>"}</script></section></div></main></body></html>