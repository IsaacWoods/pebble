<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A checked version of `core::mem::MaybeUninit`."><title>CheckedMaybeUninit in mycelium_util::mem - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="mycelium_util" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.0-nightly (bdbbb6c6a 2024-05-26)" data-channel="nightly" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../mycelium_util/index.html">mycelium_util</a><span class="version">0.1.0</span></h2></div><h2 class="location"><a href="#">CheckedMaybeUninit</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.as_mut_ptr">as_mut_ptr</a></li><li><a href="#method.as_ptr">as_ptr</a></li><li><a href="#method.assume_init">assume_init</a></li><li><a href="#method.assume_init_drop">assume_init_drop</a></li><li><a href="#method.assume_init_mut">assume_init_mut</a></li><li><a href="#method.assume_init_read">assume_init_read</a></li><li><a href="#method.assume_init_ref">assume_init_ref</a></li><li><a href="#method.new">new</a></li><li><a href="#method.uninit">uninit</a></li><li><a href="#method.write">write</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Debug-for-CheckedMaybeUninit%3CT%3E">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-CheckedMaybeUninit%3CT%3E">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-CheckedMaybeUninit%3CT%3E">RefUnwindSafe</a></li><li><a href="#impl-Send-for-CheckedMaybeUninit%3CT%3E">Send</a></li><li><a href="#impl-Sync-for-CheckedMaybeUninit%3CT%3E">Sync</a></li><li><a href="#impl-Unpin-for-CheckedMaybeUninit%3CT%3E">Unpin</a></li><li><a href="#impl-UnwindSafe-for-CheckedMaybeUninit%3CT%3E">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Instrument-for-T">Instrument</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In mycelium_util::mem</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../index.html">mycelium_util</a>::<wbr><a href="index.html">mem</a>::<wbr><a class="struct" href="#">CheckedMaybeUninit</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/mycelium_util/mem/maybe_uninit.rs.html#17-21">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct CheckedMaybeUninit&lt;T&gt; { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A checked version of <a href="union.MaybeUninit.html" title="union mycelium_util::mem::MaybeUninit"><code>core::mem::MaybeUninit</code></a>.</p>
<p>This is similar to <a href="union.MaybeUninit.html" title="union mycelium_util::mem::MaybeUninit"><code>core::mem::MaybeUninit</code></a> in release builds. In debug
mode builds, it additionally stores a flag tracking whether the value is
initialized, and asserts that the cell is initialized when it is accessed.</p>
<h2 id="differences-from-maybeuninit"><a class="doc-anchor" href="#differences-from-maybeuninit">§</a>Differences from <code>MaybeUninit</code></h2>
<p>This type is <strong>not</strong> capable of tracking initialization of
partially-initialized values, so it lacks <code>core::mem::MaybeUninit</code>’s array
and slice methods. Additionally, it does not implement a version of
<a href="union.MaybeUninit.html#method.zeroed" title="associated function mycelium_util::mem::MaybeUninit::zeroed"><code>MaybeUninit::zeroed</code></a>, because it does not know whether a zeroed <code>T</code> is
valid or not.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-CheckedMaybeUninit%3CT%3E" class="impl"><a class="src rightside" href="../../src/mycelium_util/mem/maybe_uninit.rs.html#23-416">source</a><a href="#impl-CheckedMaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="struct" href="struct.CheckedMaybeUninit.html" title="struct mycelium_util::mem::CheckedMaybeUninit">CheckedMaybeUninit</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../src/mycelium_util/mem/maybe_uninit.rs.html#33-39">source</a><h4 class="code-header">pub const fn <a href="#method.new" class="fn">new</a>(val: T) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a new <code>CheckedMaybeUninit&lt;T&gt;</code> initialized with the given value.
It is safe to call <a href="struct.CheckedMaybeUninit.html#method.assume_init" title="method mycelium_util::mem::CheckedMaybeUninit::assume_init"><code>assume_init</code></a> on the return value of this function.</p>
<p>Note that dropping a <code>CheckedMaybeUninit&lt;T&gt;</code> will never call <code>T</code>’s drop code.
It is your responsibility to make sure <code>T</code> gets dropped if it got initialized.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.uninit" class="method"><a class="src rightside" href="../../src/mycelium_util/mem/maybe_uninit.rs.html#49-55">source</a><h4 class="code-header">pub const fn <a href="#method.uninit" class="fn">uninit</a>() -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a new <code>CheckedMaybeUninit&lt;T&gt;</code> in an uninitialized state.</p>
<p>Note that dropping a <code>CheckedMaybeUninit&lt;T&gt;</code> will never call <code>T</code>’s drop code.
It is your responsibility to make sure <code>T</code> gets dropped if it got initialized.</p>
<p>See the <a href="struct.CheckedMaybeUninit.html" title="struct mycelium_util::mem::CheckedMaybeUninit">type-level documentation</a> for some examples.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write" class="method"><a class="src rightside" href="../../src/mycelium_util/mem/maybe_uninit.rs.html#76-78">source</a><h4 class="code-header">pub fn <a href="#method.write" class="fn">write</a>(&amp;mut self, val: T) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class="docblock"><p>Sets the value of the <code>CheckedMaybeUninit&lt;T&gt;</code>.</p>
<p>This overwrites any previous value without dropping it, so be careful
not to use this twice unless you want to skip running the destructor.
For your convenience, this also returns a mutable reference to the
(now safely initialized) contents of <code>self</code>.</p>
<p>As the content is stored inside a <code>CheckedMaybeUninit</code>, the destructor is not
run for the inner data if the MaybeUninit leaves scope without a call to
<a href="struct.CheckedMaybeUninit.html#method.assume_init" title="method mycelium_util::mem::CheckedMaybeUninit::assume_init"><code>assume_init</code></a>, <a href="struct.CheckedMaybeUninit.html#method.assume_init_drop" title="method mycelium_util::mem::CheckedMaybeUninit::assume_init_drop"><code>assume_init_drop</code></a>, or similar. Code that receives
the mutable reference returned by this function needs to keep this in
mind. The safety model of Rust regards leaks as safe, but they are
usually still undesirable. This being said, the mutable reference
behaves like any other mutable reference would, so assigning a new value
to it will drop the old content.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_ptr" class="method"><a class="src rightside" href="../../src/mycelium_util/mem/maybe_uninit.rs.html#86-88">source</a><h4 class="code-header">pub fn <a href="#method.as_ptr" class="fn">as_ptr</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*const T</a></h4></section></summary><div class="docblock"><p>Gets a pointer to the contained value. Reading from this pointer or turning it
into a reference is undefined behavior unless the <code>CheckedMaybeUninit&lt;T&gt;</code> is initialized.
Writing to memory that this pointer (non-transitively) points to is undefined behavior
(except inside an <code>UnsafeCell&lt;T&gt;</code>).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_mut_ptr" class="method"><a class="src rightside" href="../../src/mycelium_util/mem/maybe_uninit.rs.html#94-96">source</a><h4 class="code-header">pub fn <a href="#method.as_mut_ptr" class="fn">as_mut_ptr</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.pointer.html">*mut T</a></h4></section></summary><div class="docblock"><p>Gets a mutable pointer to the contained value. Reading from this pointer or turning it
into a reference is undefined behavior unless the <code>CheckedMaybeUninit&lt;T&gt;</code> is initialized.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.assume_init" class="method"><a class="src rightside" href="../../src/mycelium_util/mem/maybe_uninit.rs.html#145-147">source</a><h4 class="code-header">pub unsafe fn <a href="#method.assume_init" class="fn">assume_init</a>(self) -&gt; T</h4></section></summary><div class="docblock"><p>Extracts the value from the <code>CheckedMaybeUninit&lt;T&gt;</code> container. This is a great way
to ensure that the data will get dropped, because the resulting <code>T</code> is
subject to the usual drop handling.</p>
<h5 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h5>
<p>It is up to the caller to guarantee that the <code>CheckedMaybeUninit&lt;T&gt;</code> really is in an initialized
state. Calling this when the content is not yet fully initialized causes immediate undefined
behavior. The <a href="#initialization-invariant">type-level documentation</a> contains more information about
this initialization invariant.</p>
<p>On top of that, remember that most types have additional invariants beyond merely
being considered initialized at the type level. For example, a <code>1</code>-initialized <a href="../../std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a>
is considered initialized (under the current implementation; this does not constitute
a stable guarantee) because the only requirement the compiler knows about it
is that the data pointer must be non-null. Creating such a <code>Vec&lt;T&gt;</code> does not cause
<em>immediate</em> undefined behavior, but will cause undefined behavior with most
safe operations (including dropping it).</p>
<h5 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h5>
<p>Correct usage of this method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;bool&gt;::uninit();
x.write(<span class="bool-val">true</span>);
<span class="kw">let </span>x_init = <span class="kw">unsafe </span>{ x.assume_init() };
<span class="macro">assert_eq!</span>(x_init, <span class="bool-val">true</span>);</code></pre></div>
<p><em>Incorrect</em> usage of this method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();
<span class="kw">let </span>x_init = <span class="kw">unsafe </span>{ x.assume_init() };
<span class="comment">// `x` had not been initialized yet, so this last line caused undefined behavior. ⚠️</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.assume_init_read" class="method"><a class="src rightside" href="../../src/mycelium_util/mem/maybe_uninit.rs.html#174-176">source</a><h4 class="code-header">pub unsafe fn <a href="#method.assume_init_read" class="fn">assume_init_read</a>(&amp;self) -&gt; T</h4></section></summary><div class="docblock"><p>Reads the value from the <code>CheckedMaybeUninit&lt;T&gt;</code> container. The resulting <code>T</code> is subject
to the usual drop handling.</p>
<p>Whenever possible, it is preferable to use <a href="union.MaybeUninit.html#method.assume_init" title="method mycelium_util::mem::MaybeUninit::assume_init"><code>assume_init</code></a> instead, which
prevents duplicating the content of the <code>CheckedMaybeUninit&lt;T&gt;</code>.</p>
<h5 id="safety-1"><a class="doc-anchor" href="#safety-1">§</a>Safety</h5>
<p>It is up to the caller to guarantee that the <code>CheckedMaybeUninit&lt;T&gt;</code> really is in an initialized
state. Calling this when the content is not yet fully initialized causes undefined
behavior. The <a href="#initialization-invariant">type-level documentation</a> contains more information about
this initialization invariant.</p>
<p>Moreover, similar to the <a href="https://doc.rust-lang.org/nightly/core/ptr/fn.read.html" title="fn core::ptr::read"><code>ptr::read</code></a> function, this function creates a
bitwise copy of the contents, regardless whether the contained type
implements the <a href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy"><code>Copy</code></a> trait or not. When using multiple copies of the
data (by calling <code>assume_init_read</code> multiple times, or first calling
<code>assume_init_read</code> and then <a href="union.MaybeUninit.html#method.assume_init" title="method mycelium_util::mem::MaybeUninit::assume_init"><code>assume_init</code></a>), it is your responsibility
to ensure that that data may indeed be duplicated.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.assume_init_drop" class="method"><a class="src rightside" href="../../src/mycelium_util/mem/maybe_uninit.rs.html#201-203">source</a><h4 class="code-header">pub unsafe fn <a href="#method.assume_init_drop" class="fn">assume_init_drop</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Drops the contained value in place.</p>
<p>If you have ownership of the <code>CheckedMaybeUninit</code>, you can also use
<a href="union.MaybeUninit.html#method.assume_init" title="method mycelium_util::mem::MaybeUninit::assume_init"><code>assume_init</code></a> as an alternative.</p>
<h5 id="safety-2"><a class="doc-anchor" href="#safety-2">§</a>Safety</h5>
<p>It is up to the caller to guarantee that the <code>CheckedMaybeUninit&lt;T&gt;</code> really is
in an initialized state. Calling this when the content is not yet fully
initialized causes undefined behavior.</p>
<p>On top of that, all additional invariants of the type <code>T</code> must be
satisfied, as the <code>Drop</code> implementation of <code>T</code> (or its members) may
rely on this. For example, setting a [<code>Vec&lt;T&gt;</code>] to an invalid but
non-null address makes it initialized (under the current implementation;
this does not constitute a stable guarantee), because the only
requirement the compiler knows about it is that the data pointer must be
non-null. Dropping such a <code>Vec&lt;T&gt;</code> however will cause undefined
behaviour.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.assume_init_ref" class="method"><a class="src rightside" href="../../src/mycelium_util/mem/maybe_uninit.rs.html#259-261">source</a><h4 class="code-header">pub unsafe fn <a href="#method.assume_init_ref" class="fn">assume_init_ref</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.reference.html">&amp;T</a></h4></section></summary><div class="docblock"><p>Gets a shared reference to the contained value.</p>
<p>This can be useful when we want to access a <code>CheckedMaybeUninit</code> that has been
initialized but don’t have ownership of the <code>CheckedMaybeUninit</code> (preventing the use
of <code>.assume_init()</code>).</p>
<h5 id="safety-3"><a class="doc-anchor" href="#safety-3">§</a>Safety</h5>
<p>Calling this when the content is not yet fully initialized causes undefined
behavior: it is up to the caller to guarantee that the <code>CheckedMaybeUninit&lt;T&gt;</code> really
is in an initialized state.</p>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h5><h6 id="correct-usage-of-this-method"><a class="doc-anchor" href="#correct-usage-of-this-method">§</a>Correct usage of this method:</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();
<span class="comment">// Initialize `x`:
</span>x.write(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);
<span class="comment">// Now that our `CheckedMaybeUninit&lt;_&gt;` is known to be initialized, it is okay to
// create a shared reference to it:
</span><span class="kw">let </span>x: <span class="kw-2">&amp;</span>Vec&lt;u32&gt; = <span class="kw">unsafe </span>{
    <span class="comment">// SAFETY: `x` has been initialized.
    </span>x.assume_init_ref()
};
<span class="macro">assert_eq!</span>(x, <span class="kw-2">&amp;</span><span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</code></pre></div>
<h6 id="incorrect-usages-of-this-method"><a class="doc-anchor" href="#incorrect-usages-of-this-method">§</a><em>Incorrect</em> usages of this method:</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();
<span class="kw">let </span>x_vec: <span class="kw-2">&amp;</span>Vec&lt;u32&gt; = <span class="kw">unsafe </span>{ x.assume_init_ref() };
<span class="comment">// We have created a reference to an uninitialized vector! This is undefined behavior. ⚠️</span></code></pre></div>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::{cell::Cell, mem::MaybeUninit};

<span class="kw">let </span>b = MaybeUninit::&lt;Cell&lt;bool&gt;&gt;::uninit();
<span class="comment">// Initialize the `CheckedMaybeUninit` using `Cell::set`:
</span><span class="kw">unsafe </span>{
    b.assume_init_ref().set(<span class="bool-val">true</span>);
   <span class="comment">// ^^^^^^^^^^^^^^^
   // Reference to an uninitialized `Cell&lt;bool&gt;`: UB!
</span>}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.assume_init_mut" class="method"><a class="src rightside" href="../../src/mycelium_util/mem/maybe_uninit.rs.html#371-373">source</a><h4 class="code-header">pub unsafe fn <a href="#method.assume_init_mut" class="fn">assume_init_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class="docblock"><p>Gets a mutable (unique) reference to the contained value.</p>
<p>This can be useful when we want to access a <code>CheckedMaybeUninit</code> that has been
initialized but don’t have ownership of the <code>CheckedMaybeUninit</code> (preventing the use
of <code>.assume_init()</code>).</p>
<h5 id="safety-4"><a class="doc-anchor" href="#safety-4">§</a>Safety</h5>
<p>Calling this when the content is not yet fully initialized causes undefined
behavior: it is up to the caller to guarantee that the <code>CheckedMaybeUninit&lt;T&gt;</code> really
is in an initialized state. For instance, <code>.assume_init_mut()</code> cannot be used to
initialize a <code>CheckedMaybeUninit</code>.</p>
<h5 id="examples-2"><a class="doc-anchor" href="#examples-2">§</a>Examples</h5><h6 id="correct-usage-of-this-method-1"><a class="doc-anchor" href="#correct-usage-of-this-method-1">§</a>Correct usage of this method:</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="doccomment">/// Initializes *all* the bytes of the input buffer.
    </span><span class="kw">fn </span>initialize_buffer(buf: <span class="kw-2">*mut </span>[u8; <span class="number">1024</span>]);
}

<span class="kw">let </span><span class="kw-2">mut </span>buf = MaybeUninit::&lt;[u8; <span class="number">1024</span>]&gt;::uninit();

<span class="comment">// Initialize `buf`:
</span><span class="kw">unsafe </span>{ initialize_buffer(buf.as_mut_ptr()); }
<span class="comment">// Now we know that `buf` has been initialized, so we could `.assume_init()` it.
// However, using `.assume_init()` may trigger a `memcpy` of the 1024 bytes.
// To assert our buffer has been initialized without copying it, we upgrade
// the `&amp;mut MaybeUninit&lt;[u8; 1024]&gt;` to a `&amp;mut [u8; 1024]`:
</span><span class="kw">let </span>buf: <span class="kw-2">&amp;mut </span>[u8; <span class="number">1024</span>] = <span class="kw">unsafe </span>{
    <span class="comment">// SAFETY: `buf` has been initialized.
    </span>buf.assume_init_mut()
};

<span class="comment">// Now we can use `buf` as a normal slice:
</span>buf.sort_unstable();
<span class="macro">debug_assert!</span>(
    buf.windows(<span class="number">2</span>).all(|pair| pair[<span class="number">0</span>] &lt;= pair[<span class="number">1</span>]),
    <span class="string">"buffer is sorted"</span>,
);</code></pre></div>
<h6 id="incorrect-usages-of-this-method-1"><a class="doc-anchor" href="#incorrect-usages-of-this-method-1">§</a><em>Incorrect</em> usages of this method:</h6>
<p>You cannot use <code>.assume_init_mut()</code> to initialize a value:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>b = MaybeUninit::&lt;bool&gt;::uninit();
<span class="kw">unsafe </span>{
    <span class="kw-2">*</span>b.assume_init_mut() = <span class="bool-val">true</span>;
    <span class="comment">// We have created a (mutable) reference to an uninitialized `bool`!
    // This is undefined behavior. ⚠️
</span>}</code></pre></div>
<p>For instance, you cannot <a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a> into an uninitialized buffer:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::{io, mem::MaybeUninit};

<span class="kw">fn </span>read_chunk (reader: <span class="kw-2">&amp;</span><span class="lifetime">'_ </span><span class="kw-2">mut </span><span class="kw">dyn </span>io::Read) -&gt; io::Result&lt;[u8; <span class="number">64</span>]&gt;
{
    <span class="kw">let </span><span class="kw-2">mut </span>buffer = MaybeUninit::&lt;[u8; <span class="number">64</span>]&gt;::uninit();
    reader.read_exact(<span class="kw">unsafe </span>{ buffer.assume_init_mut() })<span class="question-mark">?</span>;
                            <span class="comment">// ^^^^^^^^^^^^^^^^^^^^^^^^
                            // (mutable) reference to uninitialized memory!
                            // This is undefined behavior.
    </span><span class="prelude-val">Ok</span>(<span class="kw">unsafe </span>{ buffer.assume_init() })
}</code></pre></div>
<p>Nor can you use direct field access to do field-by-field gradual initialization:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::{mem::MaybeUninit, ptr};

<span class="kw">struct </span>Foo {
    a: u32,
    b: u8,
}

<span class="kw">let </span>foo: Foo = <span class="kw">unsafe </span>{
    <span class="kw">let </span><span class="kw-2">mut </span>foo = MaybeUninit::&lt;Foo&gt;::uninit();
    ptr::write(<span class="kw-2">&amp;mut </span>foo.assume_init_mut().a <span class="kw">as </span><span class="kw-2">*mut </span>u32, <span class="number">1337</span>);
                 <span class="comment">// ^^^^^^^^^^^^^^^^^^^^^
                 // (mutable) reference to uninitialized memory!
                 // This is undefined behavior.
    </span>ptr::write(<span class="kw-2">&amp;mut </span>foo.assume_init_mut().b <span class="kw">as </span><span class="kw-2">*mut </span>u8, <span class="number">42</span>);
                 <span class="comment">// ^^^^^^^^^^^^^^^^^^^^^
                 // (mutable) reference to uninitialized memory!
                 // This is undefined behavior.
    </span>foo.assume_init()
};</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-CheckedMaybeUninit%3CT%3E" class="impl"><a class="src rightside" href="../../src/mycelium_util/mem/maybe_uninit.rs.html#418-435">source</a><a href="#impl-Debug-for-CheckedMaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="../fmt/trait.Debug.html" title="trait mycelium_util::fmt::Debug">Debug</a>&gt; <a class="trait" href="../fmt/trait.Debug.html" title="trait mycelium_util::fmt::Debug">Debug</a> for <a class="struct" href="struct.CheckedMaybeUninit.html" title="struct mycelium_util::mem::CheckedMaybeUninit">CheckedMaybeUninit</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../src/mycelium_util/mem/maybe_uninit.rs.html#419-434">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="../fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../fmt/struct.Formatter.html" title="struct mycelium_util::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="../fmt/type.Result.html" title="type mycelium_util::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="../fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-CheckedMaybeUninit%3CT%3E" class="impl"><a href="#impl-Freeze-for-CheckedMaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.CheckedMaybeUninit.html" title="struct mycelium_util::mem::CheckedMaybeUninit">CheckedMaybeUninit</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a>,</div></h3></section><section id="impl-RefUnwindSafe-for-CheckedMaybeUninit%3CT%3E" class="impl"><a href="#impl-RefUnwindSafe-for-CheckedMaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.CheckedMaybeUninit.html" title="struct mycelium_util::mem::CheckedMaybeUninit">CheckedMaybeUninit</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,</div></h3></section><section id="impl-Send-for-CheckedMaybeUninit%3CT%3E" class="impl"><a href="#impl-Send-for-CheckedMaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.CheckedMaybeUninit.html" title="struct mycelium_util::mem::CheckedMaybeUninit">CheckedMaybeUninit</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,</div></h3></section><section id="impl-Sync-for-CheckedMaybeUninit%3CT%3E" class="impl"><a href="#impl-Sync-for-CheckedMaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.CheckedMaybeUninit.html" title="struct mycelium_util::mem::CheckedMaybeUninit">CheckedMaybeUninit</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,</div></h3></section><section id="impl-Unpin-for-CheckedMaybeUninit%3CT%3E" class="impl"><a href="#impl-Unpin-for-CheckedMaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.CheckedMaybeUninit.html" title="struct mycelium_util::mem::CheckedMaybeUninit">CheckedMaybeUninit</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</div></h3></section><section id="impl-UnwindSafe-for-CheckedMaybeUninit%3CT%3E" class="impl"><a href="#impl-UnwindSafe-for-CheckedMaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.CheckedMaybeUninit.html" title="struct mycelium_util::mem::CheckedMaybeUninit">CheckedMaybeUninit</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,</div></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#140">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#141">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#765">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#768">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Instrument-for-T" class="impl"><a class="src rightside" href="../../src/tracing/instrument.rs.html#358">source</a><a href="#impl-Instrument-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../tracing/instrument/trait.Instrument.html" title="trait tracing::instrument::Instrument">Instrument</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.instrument" class="method trait-impl"><a class="src rightside" href="../../src/tracing/instrument.rs.html#86">source</a><a href="#method.instrument" class="anchor">§</a><h4 class="code-header">fn <a href="../../tracing/instrument/trait.Instrument.html#method.instrument" class="fn">instrument</a>(self, span: <a class="struct" href="../../tracing/span/struct.Span.html" title="struct tracing::span::Span">Span</a>) -&gt; <a class="struct" href="../../tracing/instrument/struct.Instrumented.html" title="struct tracing::instrument::Instrumented">Instrumented</a>&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the provided <a href="../../tracing/span/struct.Span.html" title="struct tracing::span::Span"><code>Span</code></a>, returning an
<code>Instrumented</code> wrapper. <a href="../../tracing/instrument/trait.Instrument.html#method.instrument">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.in_current_span" class="method trait-impl"><a class="src rightside" href="../../src/tracing/instrument.rs.html#128">source</a><a href="#method.in_current_span" class="anchor">§</a><h4 class="code-header">fn <a href="../../tracing/instrument/trait.Instrument.html#method.in_current_span" class="fn">in_current_span</a>(self) -&gt; <a class="struct" href="../../tracing/instrument/struct.Instrumented.html" title="struct tracing::instrument::Instrumented">Instrumented</a>&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the <a href="../../tracing/span/struct.Span.html#method.current" title="associated function tracing::span::Span::current">current</a> <a href="../../tracing/span/struct.Span.html" title="struct tracing::span::Span"><code>Span</code></a>, returning an
<code>Instrumented</code> wrapper. <a href="../../tracing/instrument/trait.Instrument.html#method.in_current_span">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#748-750">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#758">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#805-807">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#812">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#790-792">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#797">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>